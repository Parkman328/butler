{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Butler documentation\n\n\nButler is an open source add-on tool for Qlik Sense, extending that platform with various features, most of which are focused on integrating Sense with other systems.\n\nButler makes it easy to hook up Sense to systems like \nSlack\n or \nMQTT\n, and use these tools to send alerts when something important/interesting/urgent happen in a Sense environment.  \n\n\nSample use cases:  \n\n\n\n\nInformation about all failing tasks can be sent to a Slack channel. This gives sysadmins real-time insight into what's happening with respect to task execution.\n\n\nTrigger Sense tasks from a reload script. This makes it possible to start different Sense tasks based on what data has been read from a database, for example.\n\n\nAny messages sent to Slack can include full formatting (web links, text formatting etc), as well as \"poking\" users. I.e. notifying specific Slack users that they have a new message. Can for example be used to notify user(s) that an app has reloaded with new data, or that some error condition has occured. \n\n\nSend and receive MQTT publish-subscribe messages. MQTT (and the pubsub concept in general) is a great way for systems to communicate reliably with each other.\n\n\nModify the Operations Monitor app to send a daily summary of daily/weekly/monthly active users, # of failed tasks etc to a Slack channel\n\n\nReal-time monitoring of active users. This data is posted to MQTT, from where it can be plotted by various tools, see below.\n\n\nButler is fully open source, as well as written in a modular and extensible way. It is thus possible to integrate it with most other systems, as well as adding new features if/when needed.\n\n\n\n\n\nReal-time view of # of active users. This particular chart was created by sending metrics via MQTT to a \nNode-RED\n dashboard. While this works well, you might want to take a look at \nButler SOS\n if you are interested in more enterprise grade monitoring of Sense environments. Butler SOS is another open source project from \nPtarmigan Labs\n.\n\n\nAll Butler project files are stored on \nGitHub\n.\n\n\nUse the menu to the left to access the different parts of the Butler documentation.\n\n\nThroughout this documentation the words \"Qlik Sense\" and \"Sense\" are used, both referring to the product Qlik Sense from the company Qlik.\n\n\nUpdates to Butler will be published on \nGitHub\n and descried on \nPtarmigan Labs'\n site.\n\n\nGood luck and have fun!\n\n\nContributing\n\n\nPull requests and stars are always welcome. For bugs and feature requests, \nplease create an issue\n.\nOr fork the project and contribute with enhancements!  \n\n\nAuthor\n\n\nG\u00f6ran Sander\n\nWeb: \nPtarmigan Labs\n\nTwitter: \n@themountaindude\n\nLinkedIn: \nhttps://www.linkedin.com/in/gorsan/\n\n\nLicense\n\n\nCopyright \u00a9 2016-2018 G\u00f6ran Sander.\n\nReleased under the MIT license.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome_to_the_butler_documentation", 
            "text": "Butler is an open source add-on tool for Qlik Sense, extending that platform with various features, most of which are focused on integrating Sense with other systems. \nButler makes it easy to hook up Sense to systems like  Slack  or  MQTT , and use these tools to send alerts when something important/interesting/urgent happen in a Sense environment.    Sample use cases:     Information about all failing tasks can be sent to a Slack channel. This gives sysadmins real-time insight into what's happening with respect to task execution.  Trigger Sense tasks from a reload script. This makes it possible to start different Sense tasks based on what data has been read from a database, for example.  Any messages sent to Slack can include full formatting (web links, text formatting etc), as well as \"poking\" users. I.e. notifying specific Slack users that they have a new message. Can for example be used to notify user(s) that an app has reloaded with new data, or that some error condition has occured.   Send and receive MQTT publish-subscribe messages. MQTT (and the pubsub concept in general) is a great way for systems to communicate reliably with each other.  Modify the Operations Monitor app to send a daily summary of daily/weekly/monthly active users, # of failed tasks etc to a Slack channel  Real-time monitoring of active users. This data is posted to MQTT, from where it can be plotted by various tools, see below.  Butler is fully open source, as well as written in a modular and extensible way. It is thus possible to integrate it with most other systems, as well as adding new features if/when needed.   \nReal-time view of # of active users. This particular chart was created by sending metrics via MQTT to a  Node-RED  dashboard. While this works well, you might want to take a look at  Butler SOS  if you are interested in more enterprise grade monitoring of Sense environments. Butler SOS is another open source project from  Ptarmigan Labs .  All Butler project files are stored on  GitHub .  Use the menu to the left to access the different parts of the Butler documentation.  Throughout this documentation the words \"Qlik Sense\" and \"Sense\" are used, both referring to the product Qlik Sense from the company Qlik.  Updates to Butler will be published on  GitHub  and descried on  Ptarmigan Labs'  site.  Good luck and have fun!", 
            "title": "Welcome to the Butler documentation"
        }, 
        {
            "location": "/#contributing", 
            "text": "Pull requests and stars are always welcome. For bugs and feature requests,  please create an issue .\nOr fork the project and contribute with enhancements!", 
            "title": "Contributing"
        }, 
        {
            "location": "/#author", 
            "text": "G\u00f6ran Sander \nWeb:  Ptarmigan Labs \nTwitter:  @themountaindude \nLinkedIn:  https://www.linkedin.com/in/gorsan/", 
            "title": "Author"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2016-2018 G\u00f6ran Sander. \nReleased under the MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/overview/", 
            "text": "Overview\n\n\nButler is a Node.js based proxy app for providing add-on features to Qlik Sense.\n\nSome of the features can be used from Sense load scripts, while other provide integration with other systems.\n\n\nThe app started out as a way of posting to \nSlack\n from Qlik Sense load scripts, but has since been generalized and now supports the following high level features:\n\n\n\n\nREST endpoints that can be called from Sense load scripts or external systems.\n\n\nEvent proxies used to forward messages from Sense's logging framework.\n\n\nIn- and outbound MQTT messages for stable, reliable machine-to-machine communication and notifications\n\n\n\n\nREST endpoints\n\n\n\n\n\n\n\n\nEndpoint\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n/v2/activeUserCount\n\n\n# of users with open Sense sessions\n\n\n\n\n\n\n/v2/activeUsers\n\n\nUsernames of users with open Sense sessions\n\n\n\n\n\n\n/v2/butlerPing\n\n\nChecks if Butler is running\n\n\n\n\n\n\n/v2/createDir\n\n\nCreate directories (anywhere in the file system) on the server where Butler is running\n\n\n\n\n\n\n/v2/createDirQVD\n\n\nCreate directories (relative to a hard coded path) on the server where Butler is running\n\n\n\n\n\n\n/v2/getDiskSpace\n\n\nCheck available disk space\nRemoved in v2.1 due to difficulties getting consistent behaviour across Windows, Linux and Mac OS\n\n\n\n\n\n\n/v2/mqttPublishMessage\n\n\nPublish message to MQTT topic\n\n\n\n\n\n\n/v2/senseAppDump\n\n\nRetrieves metadata (load script etc) about a Sense app\n\n\n\n\n\n\n/v2/senseListApps\n\n\nList name and GUID of all Sense apps in the system\n\n\n\n\n\n\n/v2/senseStartTask\n\n\nStart a Sense task. Can for example be used by upstream data providers to trigger reloads of Sense apps\n\n\n\n\n\n\n/v2/slackPostMessage\n\n\nPost to Slack from Sense load scripts\n\n\n\n\n\n\n\n\nHandler for Sense log messages\n\n\nIt is possible to hook into Sense's logging framework, and have log events forwarded to Butler. Once there, Butler can act as needed on the messages.\n\nCurrently Butler forwards messages to Slack (for notifying humans that some event occurred) and MQTT (for notifying other systems that some event occurred).\n\nMore info \nhere\n. \n\n\nReal time active user data\n\n\nButler keeps track of how many and which users are currently using Sense. This information is also published as MQTT messages.   \n\n\nMQTT handlers\n\n\nMQTT is a light weight pub-sub protocol developed for efficient machine-to-machine message sending. The protocol was developed with embedded systems (IoT and other low CPU/memory systems) in mind, and there are client implementations available in many different languages/platforms. It is also a mature protocol that has proven its stability over many years.  \n\n\nAdding in- and out-bound MQTT support to Sense opens up a very interesting set of possibilities:   \n\n\n\n\nStart Sense tasks when a message arrives in a particular MQTT topic. Other systems can very easily trigger Sense reloads this way. Many cases where upstream sources are today polled can be avoided, with lower server load and more up-to-date data for end users as results.\n\n\nSend MQTT messages from Sense load script, notifying other systems that some set of files have been created and are available for consumption.\n\n\nUse as a real-time debugging channel during development of Sense apps. By sending MQTT messages from the load script, the developer can inspect the value of variables, tables etc during different parts of the reload process.\n\n\n\n\nExtending Butler\n\n\nGiven the richness of the Sense APIs, it is easy to add new REST endpoints that encapsulate API functions of interest.\nOn the other hand, given the vast number of modules in npm, it is quite easy to add integrations to additional services. Current ideas include linking to services like \nPushover\n, sending tweets, controlling USB status lights like \nBlink(1)\n etc.  \n\n\n*\nForward user audit events (session start/stop, connection open/close) to Slack and MQTT", 
            "title": "Overview and features"
        }, 
        {
            "location": "/overview/#overview", 
            "text": "Butler is a Node.js based proxy app for providing add-on features to Qlik Sense. \nSome of the features can be used from Sense load scripts, while other provide integration with other systems.  The app started out as a way of posting to  Slack  from Qlik Sense load scripts, but has since been generalized and now supports the following high level features:   REST endpoints that can be called from Sense load scripts or external systems.  Event proxies used to forward messages from Sense's logging framework.  In- and outbound MQTT messages for stable, reliable machine-to-machine communication and notifications", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#rest_endpoints", 
            "text": "Endpoint  Description      /v2/activeUserCount  # of users with open Sense sessions    /v2/activeUsers  Usernames of users with open Sense sessions    /v2/butlerPing  Checks if Butler is running    /v2/createDir  Create directories (anywhere in the file system) on the server where Butler is running    /v2/createDirQVD  Create directories (relative to a hard coded path) on the server where Butler is running    /v2/getDiskSpace  Check available disk space Removed in v2.1 due to difficulties getting consistent behaviour across Windows, Linux and Mac OS    /v2/mqttPublishMessage  Publish message to MQTT topic    /v2/senseAppDump  Retrieves metadata (load script etc) about a Sense app    /v2/senseListApps  List name and GUID of all Sense apps in the system    /v2/senseStartTask  Start a Sense task. Can for example be used by upstream data providers to trigger reloads of Sense apps    /v2/slackPostMessage  Post to Slack from Sense load scripts", 
            "title": "REST endpoints"
        }, 
        {
            "location": "/overview/#handler_for_sense_log_messages", 
            "text": "It is possible to hook into Sense's logging framework, and have log events forwarded to Butler. Once there, Butler can act as needed on the messages. \nCurrently Butler forwards messages to Slack (for notifying humans that some event occurred) and MQTT (for notifying other systems that some event occurred). \nMore info  here .", 
            "title": "Handler for Sense log messages"
        }, 
        {
            "location": "/overview/#real_time_active_user_data", 
            "text": "Butler keeps track of how many and which users are currently using Sense. This information is also published as MQTT messages.", 
            "title": "Real time active user data"
        }, 
        {
            "location": "/overview/#mqtt_handlers", 
            "text": "MQTT is a light weight pub-sub protocol developed for efficient machine-to-machine message sending. The protocol was developed with embedded systems (IoT and other low CPU/memory systems) in mind, and there are client implementations available in many different languages/platforms. It is also a mature protocol that has proven its stability over many years.    Adding in- and out-bound MQTT support to Sense opens up a very interesting set of possibilities:      Start Sense tasks when a message arrives in a particular MQTT topic. Other systems can very easily trigger Sense reloads this way. Many cases where upstream sources are today polled can be avoided, with lower server load and more up-to-date data for end users as results.  Send MQTT messages from Sense load script, notifying other systems that some set of files have been created and are available for consumption.  Use as a real-time debugging channel during development of Sense apps. By sending MQTT messages from the load script, the developer can inspect the value of variables, tables etc during different parts of the reload process.", 
            "title": "MQTT handlers"
        }, 
        {
            "location": "/overview/#extending_butler", 
            "text": "Given the richness of the Sense APIs, it is easy to add new REST endpoints that encapsulate API functions of interest.\nOn the other hand, given the vast number of modules in npm, it is quite easy to add integrations to additional services. Current ideas include linking to services like  Pushover , sending tweets, controlling USB status lights like  Blink(1)  etc.    *\nForward user audit events (session start/stop, connection open/close) to Slack and MQTT", 
            "title": "Extending Butler"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting started\n\n\nSorry - there is no installer for Butler.\n\nYou will need to work a bit on the command line to set things up.  \n\n\nIt's not as bad as it sounds though.\n\nEither you install a few pieces of software (most notably \nnode.js\n and some node modules), or you run Butler in a Docker container.\n\nEither way you also need to edit the configuration file and provide certificates exported from Qlik Sense Enterprise.\n\n\nFollow the \ninstallation and configuration instructions\n - they will guide through the setup process, including requirements and customisation.\n\n\nThen browse through \nthe examples\n to get an understanding of how to use Butler.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting_started", 
            "text": "Sorry - there is no installer for Butler. \nYou will need to work a bit on the command line to set things up.    It's not as bad as it sounds though. \nEither you install a few pieces of software (most notably  node.js  and some node modules), or you run Butler in a Docker container. \nEither way you also need to edit the configuration file and provide certificates exported from Qlik Sense Enterprise.  Follow the  installation and configuration instructions  - they will guide through the setup process, including requirements and customisation.  Then browse through  the examples  to get an understanding of how to use Butler.", 
            "title": "Getting started"
        }, 
        {
            "location": "/project-layout/", 
            "text": "Project layout\n\n\nThe GitHub repository consists of the following parts:\n\n\nbutler-docs/              # Main documentation folder, created using MkDocs\n  docs/                   # The configuration file\n    index.md              # The documentation homepage\n    ...                   # Other markdown pages, images and other files.\n\nlog4net_task_failed/      # Logging appender XML file\n  LocalLogConfig.XML      # Forwarding of failed task events\n\nlog4net_user-audit-event/ # Logging appender XML files\n  LocalLogConfig.XML      # Forwarding of session events\n\nsense_script/             # Qlik Sense .qvs script files\n  butler_init.qvs\n  create_directory.qvs\n  post_to_mqtt.qvs\n  post_to_slack.qvs  \n  ...\n\nsrc/                      # Butler source code\n  config/\n  mqtt/\n  qrsUtil/\n  rest/\n  udp/\n  udp_client/\n  butler.js\n  globals.js\n  package.json\n  README.md\n  ...\n\nREADME.md                 # Main GitHub readme file", 
            "title": "Project layout"
        }, 
        {
            "location": "/project-layout/#project_layout", 
            "text": "The GitHub repository consists of the following parts:  butler-docs/              # Main documentation folder, created using MkDocs\n  docs/                   # The configuration file\n    index.md              # The documentation homepage\n    ...                   # Other markdown pages, images and other files.\n\nlog4net_task_failed/      # Logging appender XML file\n  LocalLogConfig.XML      # Forwarding of failed task events\n\nlog4net_user-audit-event/ # Logging appender XML files\n  LocalLogConfig.XML      # Forwarding of session events\n\nsense_script/             # Qlik Sense .qvs script files\n  butler_init.qvs\n  create_directory.qvs\n  post_to_mqtt.qvs\n  post_to_slack.qvs  \n  ...\n\nsrc/                      # Butler source code\n  config/\n  mqtt/\n  qrsUtil/\n  rest/\n  udp/\n  udp_client/\n  butler.js\n  globals.js\n  package.json\n  README.md\n  ...\n\nREADME.md                 # Main GitHub readme file", 
            "title": "Project layout"
        }, 
        {
            "location": "/install-config/", 
            "text": "Requirements\n\n\nButler depends on various pieces of software. Some are required, others are optional, as described below.\n\n\nRunning natively\n\n\nIf you opt to run Butler nateively on Node.js installed on a computer, the following software is needed:\n\n\n\n\n\n\n\n\nWhat\n\n\nComment\n\n\n\n\n\n\n\n\n\n\nSense Enterprise\n\n\nButler is developed with Sense Enterprise in mind. While many Butler features might also work with Sense Desktop, you are on your own there.\n\n\n\n\n\n\nMQTT broker\n\n\nMQTT is used for both in- and out-bound pub-sub messaging. Butler assumes a working MQTT broker is available, the IP of which is defined in the Butler config file. Mosquitto is a nice open source broker. It requires very little hardware to run, even the smallest (free!) Amazon EC2 instance is enough, if you want a dedicated MQTT server. If you don't care about the pubsub features of Butler, you don't need a MQTT broker. In this case you can disable the MQTT features in the config YAML file.\n\n\n\n\n\n\nnode.js\n\n\nButler is written in Node - which is thus a firm requirement.\n\n\n\n\n\n\n\n\nRunning on Docker\n\n\nIf you have access or can set up a Docker runtime environment, this is by far the preferred solution for running Butler. \nInstallation is less error prone that installing Butler natively, you get all the benefits from the Docker ecosystem (monitoring of running containers etc), and upgrades to future Butler versions become trivial.\n\n\n\n\n\n\n\n\nWhat\n\n\nComment\n\n\n\n\n\n\n\n\n\n\nSense Enterprise\n\n\nSame as above.\n\n\n\n\n\n\nMQTT broker\n\n\nSame as above.\n\n\n\n\n\n\nDocker\n\n\nA Docker runtime environment on any supported platform. This means you can run Butler on any platform where Docker is available, including Linux, Mac OS, Windows and most cloud providers.\n\n\n\n\n\n\n\n\nWindows or OSX\n\n\nWhile Sense is a Windows only system, Butler should be able to run on any OS where node.js is available.\n\nButler has been succesfully used - both during development and production use - on Windows, Linux (Debian and Ubuntu tested) and OSX.\n\n\nInstallation\n\n\nBelow are the general steps needed to install Butler. Please note that you might need to adapt these to your particular system configuration.  \n\n\nInstall on native Node.js\n\n\n\n\n\n\nInstall node.js\n\n  Butler has been developed and tested using the 64 bit version of \nnode.js\n 8.11.4.  \n\n\n\n\n\n\nDecide where to install Butler\n\n  It is usually a good starting point to run Butler on the Sense server. If there are more than one server in the Sense cluster, Butler can be placed on the reload server (as the /createDir endpoint then can be used to create folders in which QVD and other files can be stored).\n  That said, it is quite possible to run Butler on any server, as long as there is network connectivity to the Sense server(s).  \n\n\n\n\n\n\nDownload Butler\n\n  Download the repository zip file or clone the Butler repository using your git tool of choice. Both options achieve the same thing, i.e. a directory such as d:\\node\\butler, which is then Butler's root directory.  \n\n\n\n\n\n\nInstall node dependencies\n\n  From a Windows command prompt (assuming Butler was installed to d:\\node\\butler):  \n\n\nd:\ncd \\node\\butler\\src\nnpm install\n\n\n\nThis will download and install all node.js modules used by Butler.  \n\n\n\n\n\n\nMQTT message broker\n\n\n\n\n\n\nMany of Butler's features use \nMQTT\n for sending and receiving messages.\n\nMQTT is a standardised messaging protocol, and it should be possible to use \nany broker following the MQTT standard\n.\n\nButler has been developed and tested using \nMosquitto\n running on OSX and Debian Linux - both work flawlessly.\n\n\n\n\nDocumentation dependencies\n\n\n\n\nIf you plan to modify or extend Butler's documentation, you will need to install \nMkDocs\n.\n\n  MkDocs is used to create the pages you are reading right now.\n\n\nInstall on Docker\n\n\nThe following steps should give some guidance on how to get Butler running on Docker.\n\n\nproton:~ goran$ mkdir /Users/goran/butler\nproton:~ goran$ cd /Users/goran/butler\nproton:butler goran$ mkdir -p config/certificate\nproton:butler goran$\nproton:butler goran$ wget https://raw.githubusercontent.com/ptarmiganlabs/butler/master/src/docker-compose.yml\n--2018-09-26 16:27:14--  https://raw.githubusercontent.com/ptarmiganlabs/butler/master/src/docker-compose.yml\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.84.133\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.84.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 565 [text/plain]\nSaving to: 'docker-compose.yml.1'\n\ndocker-compose.yml.1                                       100%[========================================================================================================================================\n]     565  --.-KB/s    in 0s\n\n2018-09-26 16:27:15 (6.34 MB/s) - 'docker-compose.yml.1' saved [565/565]\n\nproton:butler goran$ cat docker-compose.yml\n# docker-compose.yml\nversion: '2.2'\nservices:\n  verisure-mqtt:\n    image: ptarmiganlabs/butler:latest\n    container_name: butler\n    restart: always\n    ports:\n      - \n8180:8080\n     # REST API available on port 8180 to services outside the container\n      - \n9997:9997\n     # UDP port for session connection events\n      - \n9998:9998\n     # UDP port for task failure events\n    volumes:\n      # Make config file accessible outside of container\n      - \n./config:/nodeapp/config\n\n    environment:\n      - \nNODE_ENV=production\n\n    logging:\n      driver: json-file\nproton:butler goran$\n\n\n\n\n\nAt this point you should \n\n\n\n\ncopy the certificates that you have exported from the Qlik Sense QMC, and\n\n\ncopy the \ntemplate config file\n from the GitHub repository to the ./config directory, modify it as needed based on your system(s), and rename it to production.yaml.\n\n\n\n\nWhen done, you should see something like this:\n\n\nproton:butler goran$ pwd\n/Users/goran/butler\nproton:butler goran$ ls -la\ntotal 8\ndrwxr-xr-x   4 goran  staff   128 Sep 26 16:36 .\ndrwxr-xr-x+ 59 goran  staff  1888 Sep 26 16:24 ..\ndrwxr-xr-x   4 goran  staff   128 Sep 26 16:36 config\n-rw-r--r--   1 goran  staff   565 Sep 26 16:25 docker-compose.yml\nproton:butler goran$\nproton:butler goran$ ls -la config/\ntotal 8\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 .\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 ..\ndrwxr-xr-x  6 goran  staff   192 Sep 26 16:36 certificate\n-rw-r--r--  1 goran  staff  1861 Sep 26 16:36 production.yaml\nproton:butler goran$\nproton:butler goran$ ls -la config/certificate/\ntotal 32\ndrwxr-xr-x  6 goran  staff   192 Sep 26 16:36 .\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 ..\n-rw-r--r--@ 1 goran  staff  1166 Sep 26 16:36 client.pem\n-rw-r--r--@ 1 goran  staff  1702 Sep 26 16:36 client_key.pem\n-rw-r--r--@ 1 goran  staff  1192 Sep 26 16:36 root.pem\nproton:butler goran$\n\n\n\n\nAt this point everything is ready and you can start the Butler container using docker-compose:\n\n\nproton:butler goran$ docker-compose up\nCreating butler ... done\nAttaching to butler\nbutler           | 2018-09-26T14:38:57.895Z - debug: Server for UDP server: localhost\nbutler           | 2018-09-26T14:38:57.912Z - info: REST server listening on http://[::]:8080\nbutler           | 2018-09-26T14:38:57.918Z - info: UDP server listening on 127.0.0.1:9997\nbutler           | 2018-09-26T14:38:57.930Z - info: UDP server listening on 127.0.0.1:9998\nbutler           | 2018-09-26T14:38:58.124Z - info: Connected to MQTT server 192.168.1.51:1884, with client ID mqttjs_215c09dc\n\n\n\n\n\nIf you don't have an MQTT server, you won't see the \"...Connected to MQTT server\" line.\n\n\nLet's make sure things are working by opening a new terminal window and from there requesting a list of all apps on the server:\n\n\nproton:~ goran$\nproton:~ goran$ curl \nhttp://localhost:8180/v2/senseListApps\n\n[{\nid\n:\n492a1bca-1c41-4a01-9104-543a2334c465\n,\nname\n:\n2018 sales targets\n},\n{\nid\n:\n5b243cb2-8d00-44c9-b865-08b00a0af18b\n,\nname\n:\nApp 1\n},\n...\n...\n{\nid\n:\n181d101f-986c-49c5-a457-d351058c05b4\n,\nname\n:\nTemplate app 1 DEV\n}]\nproton:~ goran$\n\n\n\n\n\nNice, looking good. \n\n\nIn the terminal where you ran docker-compose, you will see a new line saying that a app list was retrieved:\n\n\nbutler           | 2018-09-26T14:40:32.740Z - debug: Server for UDP server: localhost\nbutler           | 2018-09-26T14:40:32.746Z - info: REST server listening on http://[::]:8080\nbutler           | 2018-09-26T14:40:32.748Z - info: UDP server listening on 127.0.0.1:9997\nbutler           | 2018-09-26T14:40:32.750Z - info: UDP server listening on 127.0.0.1:9998\nbutler           | 2018-09-26T14:43:05.381Z - info: Getting list of all apps\n\n\n\n\n\nSecurity considerations\n\n\n\n\nYou should make sure to configure the firewall of the server where Buter is running, so it only accepts connections from the desired clients/IP addresses.\n\n\n\n\nA reasonable first approach would be to configure the firewall to only allow calls from localhost. That way calls to Butler can only be made from the server where Butler itself is running.\n\n\n\n\nAs of right now the MQTT connections are not secured by certificates or passwords.\n\n\n\n\nFor use within a controlled network that might be fine, but nonetheless something to keep in mind. Adding certificate based authentication (which MQTT supports) would solve this.  \n\n\n\n\nButler uses various node.js modules from \nnpm\n. If concerned about security, you should review these dependencies and decide whether there are issues in them or not.  \n\n\n\n\nSame thing with Butler itself - while efforts have been made to make Butler secure, you need to decide for yourself whether the level of security is enough for your use case.  \n\n\nButler is continuously checked for security vulnerabilities by using \nSnyk\n, with status badges shown in the readme files.\n\n\nConfiguration\n\n\nButler uses configuration files in YAML format. The config files are stored in the src\\config folder. Prior to v2.1 JSON config files were used, but as YAML is much more human readable than JSON, a switch was made. JSON config files can still be used, but YAML is the default starting with v2.1.\n\n\nButler comes with a default config file called \ndefault_template.yaml\n. Make a copy of it, then rename the copy to \ndefault.yaml\n or \nproduction.yaml\n.\n\nUpdate it as needed (see below for details).\n\n\nTrying to run Butler with the default config file (the one included in the files download from GitHub) will not work - you need to adapt it to your server environment.\n\n\nNote: Butler uses the \nnode-config\n module to handle config files. As per node-config's documentation, to switch to using the production.yaml config file, at a command prompt type (for Windows)\n\n\nset NODE_ENV=production\n\n\n\nbefore starting Butler with \nnode butler.js\n.\n\n  If developing on OSX or Linux, instead use  \n\n\nexport NODE_ENV=production\n\n\n\nYou may want to set that variable during server boot, to ensure Butler starts properly when the server is rebooted.\n\n\nConfig file syntax\n\n\nThe \ndefault_template.yaml\n config file looks like this:\n\n\n---\nButler:\n  slackConfig:\n    webhookURL: \nfill in your web hook URL from Slack\n\n    loginNotificationChannel: sense-user-activity\n    taskFailureChannel: sense-task-failure\n  mqttConfig:\n    brokerHost: \nFQDN or IP of MQTT server\n\n    brokerPort: 1883\n    taskFailureTopic: qliksense/task_failure\n    taskFailureServerStatusTopic: qliksense/butler/task_failure_server\n    sessionStartTopic: qliksense/session/start\n    sessionStopTopic: qliksense/session/stop\n    connectionOpenTopic: qliksense/connection/open\n    connectionCloseTopic: qliksense/connection/close\n    sessionServerStatusTopic: qliksense/butler/session_server\n    activeUserCountTopic: qliksense/users/active/count\n    activeUsersTopic: qliksense/users/active/usernames\n  udpServerConfig:\n    serverIP: \nFQDN or IP of server where Butler is running\n\n    portSessionConnectionEvents: 9997\n    portTaskFailure: 9998\n  restServerConfig:\n    serverPort: 8080\n  configEngine:\n    engineVersion: 12.20.0        # Qlik Associative Engine version to use with Enigma.js\n    server: \nFQDN or IP of Sense server where Sense Engine is running\n\n    serverPort: '\nPort to connect to, usually 4747\n'\n    isSecure: 'true'\n    headers:\n      X-Qlik-User: UserDirectory=Internal;UserId=sa_repository\n    cert: \nPath to cert file\n\n    key: \nPath to key file\n\n    rejectUnauthorized: 'false'\n  configQRS:\n    authentication: certificates\n    host: \nFQDN or IP of Sense server where QRS is running\n\n    useSSL: true\n    port: 4242\n    headerKey: X-Qlik-User\n    headerValue: UserDirectory=Internal; UserId=sa_repository\n    cert: \nPath to client.pem\n\n    key: \nPath to client_key.pem\n\n    ca: \nPath to root.pem\n\n  qvdPath: \nPath to folder under which QVDs are stored\n\n  gitHub:\n    host: api.github.com\n    pathPrefix: ''\n\n\n\n\nComments:\n\n\n\n\nCurrently Butler assumes that a MQTT broker is present, and that status messages should be sent to Slack. Butler will fail with error messages if it cannot connect to a MQTT server, or if the Slack Webhook URL is not properly set.  \n\n\n\n\nFuture versions may make MQTT, Slack and other similar channels optional, using the config file.  \n\n\n\n\nThe default location cert/key files are found in (assuming a standard install of Qlik Sense) C:\\ProgramData\\Qlik\\Sense\\Repository\\Exported Certificates.Local Certificates  \n\n\n\n\nThe files to use are \nclient.pem\n and \nclient_key.pem\n. The config file can point straight to these files.\n\nOr export a new client cert/keys from the QMC and use these with Butler.\n\n\nlog4net extender config files\n\n\nButler includes a couple of xml files that when deployed to the Sense server will create real-time UDP messages for certain events (tasks failing, user sessions starting/ending etc).\n\nThese xml files should be deployed as follows:  \n\n\n\n\nTask failure events  \n\n\nXML file found in log4net_task-failed/LocalLogConfig.xml. This file includes settings to both send an email, and a UDP message when a task fails.\n\n\nXML file should be deployed to the server where reloads are done, in the C:\\ProgramData\\Qlik\\Sense\\Scheduler directory\n\n\nUser audit events\n\n\nXML file found in log4net_user-audit-event/LocalLogConfig.xml\n\n\nXML file should be deployed on the server where the proxy is running, in the C:\\ProgramData\\Qlik\\Sense\\Proxy directory\n\n\nIf there multiple proxies on different servers, it might make sense deploying the xml file on all of them, to capture all user audit events.\n\n\n\n\nCustomisation\n\n\nAs Butler offers a rather diverse set of features, everyone might not need all features. There is no single config file in which individual features can be turned on/off, but given the structure of the Butler source code it is relatively easy to disable speciifc features, or add new ones.\n\n\nFor example, to disable a particular REST API endpoint, you could just remove the registration of that endpoint from within the src/butler.js file.", 
            "title": "Installation and configuration"
        }, 
        {
            "location": "/install-config/#requirements", 
            "text": "Butler depends on various pieces of software. Some are required, others are optional, as described below.", 
            "title": "Requirements"
        }, 
        {
            "location": "/install-config/#running_natively", 
            "text": "If you opt to run Butler nateively on Node.js installed on a computer, the following software is needed:     What  Comment      Sense Enterprise  Butler is developed with Sense Enterprise in mind. While many Butler features might also work with Sense Desktop, you are on your own there.    MQTT broker  MQTT is used for both in- and out-bound pub-sub messaging. Butler assumes a working MQTT broker is available, the IP of which is defined in the Butler config file. Mosquitto is a nice open source broker. It requires very little hardware to run, even the smallest (free!) Amazon EC2 instance is enough, if you want a dedicated MQTT server. If you don't care about the pubsub features of Butler, you don't need a MQTT broker. In this case you can disable the MQTT features in the config YAML file.    node.js  Butler is written in Node - which is thus a firm requirement.", 
            "title": "Running natively"
        }, 
        {
            "location": "/install-config/#running_on_docker", 
            "text": "If you have access or can set up a Docker runtime environment, this is by far the preferred solution for running Butler. \nInstallation is less error prone that installing Butler natively, you get all the benefits from the Docker ecosystem (monitoring of running containers etc), and upgrades to future Butler versions become trivial.     What  Comment      Sense Enterprise  Same as above.    MQTT broker  Same as above.    Docker  A Docker runtime environment on any supported platform. This means you can run Butler on any platform where Docker is available, including Linux, Mac OS, Windows and most cloud providers.", 
            "title": "Running on Docker"
        }, 
        {
            "location": "/install-config/#windows_or_osx", 
            "text": "While Sense is a Windows only system, Butler should be able to run on any OS where node.js is available. \nButler has been succesfully used - both during development and production use - on Windows, Linux (Debian and Ubuntu tested) and OSX.", 
            "title": "Windows or OSX"
        }, 
        {
            "location": "/install-config/#installation", 
            "text": "Below are the general steps needed to install Butler. Please note that you might need to adapt these to your particular system configuration.", 
            "title": "Installation"
        }, 
        {
            "location": "/install-config/#install_on_native_nodejs", 
            "text": "Install node.js \n  Butler has been developed and tested using the 64 bit version of  node.js  8.11.4.      Decide where to install Butler \n  It is usually a good starting point to run Butler on the Sense server. If there are more than one server in the Sense cluster, Butler can be placed on the reload server (as the /createDir endpoint then can be used to create folders in which QVD and other files can be stored).\n  That said, it is quite possible to run Butler on any server, as long as there is network connectivity to the Sense server(s).      Download Butler \n  Download the repository zip file or clone the Butler repository using your git tool of choice. Both options achieve the same thing, i.e. a directory such as d:\\node\\butler, which is then Butler's root directory.      Install node dependencies \n  From a Windows command prompt (assuming Butler was installed to d:\\node\\butler):    d:\ncd \\node\\butler\\src\nnpm install  This will download and install all node.js modules used by Butler.      MQTT message broker    Many of Butler's features use  MQTT  for sending and receiving messages. \nMQTT is a standardised messaging protocol, and it should be possible to use  any broker following the MQTT standard . \nButler has been developed and tested using  Mosquitto  running on OSX and Debian Linux - both work flawlessly.   Documentation dependencies   If you plan to modify or extend Butler's documentation, you will need to install  MkDocs . \n  MkDocs is used to create the pages you are reading right now.", 
            "title": "Install on native Node.js"
        }, 
        {
            "location": "/install-config/#install_on_docker", 
            "text": "The following steps should give some guidance on how to get Butler running on Docker.  proton:~ goran$ mkdir /Users/goran/butler\nproton:~ goran$ cd /Users/goran/butler\nproton:butler goran$ mkdir -p config/certificate\nproton:butler goran$\nproton:butler goran$ wget https://raw.githubusercontent.com/ptarmiganlabs/butler/master/src/docker-compose.yml\n--2018-09-26 16:27:14--  https://raw.githubusercontent.com/ptarmiganlabs/butler/master/src/docker-compose.yml\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.84.133\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.84.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 565 [text/plain]\nSaving to: 'docker-compose.yml.1'\n\ndocker-compose.yml.1                                       100%[======================================================================================================================================== ]     565  --.-KB/s    in 0s\n\n2018-09-26 16:27:15 (6.34 MB/s) - 'docker-compose.yml.1' saved [565/565]\n\nproton:butler goran$ cat docker-compose.yml\n# docker-compose.yml\nversion: '2.2'\nservices:\n  verisure-mqtt:\n    image: ptarmiganlabs/butler:latest\n    container_name: butler\n    restart: always\n    ports:\n      -  8180:8080      # REST API available on port 8180 to services outside the container\n      -  9997:9997      # UDP port for session connection events\n      -  9998:9998      # UDP port for task failure events\n    volumes:\n      # Make config file accessible outside of container\n      -  ./config:/nodeapp/config \n    environment:\n      -  NODE_ENV=production \n    logging:\n      driver: json-file\nproton:butler goran$  At this point you should    copy the certificates that you have exported from the Qlik Sense QMC, and  copy the  template config file  from the GitHub repository to the ./config directory, modify it as needed based on your system(s), and rename it to production.yaml.   When done, you should see something like this:  proton:butler goran$ pwd\n/Users/goran/butler\nproton:butler goran$ ls -la\ntotal 8\ndrwxr-xr-x   4 goran  staff   128 Sep 26 16:36 .\ndrwxr-xr-x+ 59 goran  staff  1888 Sep 26 16:24 ..\ndrwxr-xr-x   4 goran  staff   128 Sep 26 16:36 config\n-rw-r--r--   1 goran  staff   565 Sep 26 16:25 docker-compose.yml\nproton:butler goran$\nproton:butler goran$ ls -la config/\ntotal 8\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 .\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 ..\ndrwxr-xr-x  6 goran  staff   192 Sep 26 16:36 certificate\n-rw-r--r--  1 goran  staff  1861 Sep 26 16:36 production.yaml\nproton:butler goran$\nproton:butler goran$ ls -la config/certificate/\ntotal 32\ndrwxr-xr-x  6 goran  staff   192 Sep 26 16:36 .\ndrwxr-xr-x  4 goran  staff   128 Sep 26 16:36 ..\n-rw-r--r--@ 1 goran  staff  1166 Sep 26 16:36 client.pem\n-rw-r--r--@ 1 goran  staff  1702 Sep 26 16:36 client_key.pem\n-rw-r--r--@ 1 goran  staff  1192 Sep 26 16:36 root.pem\nproton:butler goran$  At this point everything is ready and you can start the Butler container using docker-compose:  proton:butler goran$ docker-compose up\nCreating butler ... done\nAttaching to butler\nbutler           | 2018-09-26T14:38:57.895Z - debug: Server for UDP server: localhost\nbutler           | 2018-09-26T14:38:57.912Z - info: REST server listening on http://[::]:8080\nbutler           | 2018-09-26T14:38:57.918Z - info: UDP server listening on 127.0.0.1:9997\nbutler           | 2018-09-26T14:38:57.930Z - info: UDP server listening on 127.0.0.1:9998\nbutler           | 2018-09-26T14:38:58.124Z - info: Connected to MQTT server 192.168.1.51:1884, with client ID mqttjs_215c09dc  If you don't have an MQTT server, you won't see the \"...Connected to MQTT server\" line.  Let's make sure things are working by opening a new terminal window and from there requesting a list of all apps on the server:  proton:~ goran$\nproton:~ goran$ curl  http://localhost:8180/v2/senseListApps \n[{ id : 492a1bca-1c41-4a01-9104-543a2334c465 , name : 2018 sales targets },\n{ id : 5b243cb2-8d00-44c9-b865-08b00a0af18b , name : App 1 },\n...\n...\n{ id : 181d101f-986c-49c5-a457-d351058c05b4 , name : Template app 1 DEV }]\nproton:~ goran$  Nice, looking good.   In the terminal where you ran docker-compose, you will see a new line saying that a app list was retrieved:  butler           | 2018-09-26T14:40:32.740Z - debug: Server for UDP server: localhost\nbutler           | 2018-09-26T14:40:32.746Z - info: REST server listening on http://[::]:8080\nbutler           | 2018-09-26T14:40:32.748Z - info: UDP server listening on 127.0.0.1:9997\nbutler           | 2018-09-26T14:40:32.750Z - info: UDP server listening on 127.0.0.1:9998\nbutler           | 2018-09-26T14:43:05.381Z - info: Getting list of all apps", 
            "title": "Install on Docker"
        }, 
        {
            "location": "/install-config/#security_considerations", 
            "text": "You should make sure to configure the firewall of the server where Buter is running, so it only accepts connections from the desired clients/IP addresses.   A reasonable first approach would be to configure the firewall to only allow calls from localhost. That way calls to Butler can only be made from the server where Butler itself is running.   As of right now the MQTT connections are not secured by certificates or passwords.   For use within a controlled network that might be fine, but nonetheless something to keep in mind. Adding certificate based authentication (which MQTT supports) would solve this.     Butler uses various node.js modules from  npm . If concerned about security, you should review these dependencies and decide whether there are issues in them or not.     Same thing with Butler itself - while efforts have been made to make Butler secure, you need to decide for yourself whether the level of security is enough for your use case.    Butler is continuously checked for security vulnerabilities by using  Snyk , with status badges shown in the readme files.", 
            "title": "Security considerations"
        }, 
        {
            "location": "/install-config/#configuration", 
            "text": "Butler uses configuration files in YAML format. The config files are stored in the src\\config folder. Prior to v2.1 JSON config files were used, but as YAML is much more human readable than JSON, a switch was made. JSON config files can still be used, but YAML is the default starting with v2.1.  Butler comes with a default config file called  default_template.yaml . Make a copy of it, then rename the copy to  default.yaml  or  production.yaml . \nUpdate it as needed (see below for details).  Trying to run Butler with the default config file (the one included in the files download from GitHub) will not work - you need to adapt it to your server environment.  Note: Butler uses the  node-config  module to handle config files. As per node-config's documentation, to switch to using the production.yaml config file, at a command prompt type (for Windows)  set NODE_ENV=production  before starting Butler with  node butler.js . \n  If developing on OSX or Linux, instead use    export NODE_ENV=production  You may want to set that variable during server boot, to ensure Butler starts properly when the server is rebooted.", 
            "title": "Configuration"
        }, 
        {
            "location": "/install-config/#config_file_syntax", 
            "text": "The  default_template.yaml  config file looks like this:  ---\nButler:\n  slackConfig:\n    webhookURL:  fill in your web hook URL from Slack \n    loginNotificationChannel: sense-user-activity\n    taskFailureChannel: sense-task-failure\n  mqttConfig:\n    brokerHost:  FQDN or IP of MQTT server \n    brokerPort: 1883\n    taskFailureTopic: qliksense/task_failure\n    taskFailureServerStatusTopic: qliksense/butler/task_failure_server\n    sessionStartTopic: qliksense/session/start\n    sessionStopTopic: qliksense/session/stop\n    connectionOpenTopic: qliksense/connection/open\n    connectionCloseTopic: qliksense/connection/close\n    sessionServerStatusTopic: qliksense/butler/session_server\n    activeUserCountTopic: qliksense/users/active/count\n    activeUsersTopic: qliksense/users/active/usernames\n  udpServerConfig:\n    serverIP:  FQDN or IP of server where Butler is running \n    portSessionConnectionEvents: 9997\n    portTaskFailure: 9998\n  restServerConfig:\n    serverPort: 8080\n  configEngine:\n    engineVersion: 12.20.0        # Qlik Associative Engine version to use with Enigma.js\n    server:  FQDN or IP of Sense server where Sense Engine is running \n    serverPort: ' Port to connect to, usually 4747 '\n    isSecure: 'true'\n    headers:\n      X-Qlik-User: UserDirectory=Internal;UserId=sa_repository\n    cert:  Path to cert file \n    key:  Path to key file \n    rejectUnauthorized: 'false'\n  configQRS:\n    authentication: certificates\n    host:  FQDN or IP of Sense server where QRS is running \n    useSSL: true\n    port: 4242\n    headerKey: X-Qlik-User\n    headerValue: UserDirectory=Internal; UserId=sa_repository\n    cert:  Path to client.pem \n    key:  Path to client_key.pem \n    ca:  Path to root.pem \n  qvdPath:  Path to folder under which QVDs are stored \n  gitHub:\n    host: api.github.com\n    pathPrefix: ''  Comments:   Currently Butler assumes that a MQTT broker is present, and that status messages should be sent to Slack. Butler will fail with error messages if it cannot connect to a MQTT server, or if the Slack Webhook URL is not properly set.     Future versions may make MQTT, Slack and other similar channels optional, using the config file.     The default location cert/key files are found in (assuming a standard install of Qlik Sense) C:\\ProgramData\\Qlik\\Sense\\Repository\\Exported Certificates.Local Certificates     The files to use are  client.pem  and  client_key.pem . The config file can point straight to these files. \nOr export a new client cert/keys from the QMC and use these with Butler.", 
            "title": "Config file syntax"
        }, 
        {
            "location": "/install-config/#log4net_extender_config_files", 
            "text": "Butler includes a couple of xml files that when deployed to the Sense server will create real-time UDP messages for certain events (tasks failing, user sessions starting/ending etc). \nThese xml files should be deployed as follows:     Task failure events    XML file found in log4net_task-failed/LocalLogConfig.xml. This file includes settings to both send an email, and a UDP message when a task fails.  XML file should be deployed to the server where reloads are done, in the C:\\ProgramData\\Qlik\\Sense\\Scheduler directory  User audit events  XML file found in log4net_user-audit-event/LocalLogConfig.xml  XML file should be deployed on the server where the proxy is running, in the C:\\ProgramData\\Qlik\\Sense\\Proxy directory  If there multiple proxies on different servers, it might make sense deploying the xml file on all of them, to capture all user audit events.", 
            "title": "log4net extender config files"
        }, 
        {
            "location": "/install-config/#customisation", 
            "text": "As Butler offers a rather diverse set of features, everyone might not need all features. There is no single config file in which individual features can be turned on/off, but given the structure of the Butler source code it is relatively easy to disable speciifc features, or add new ones.  For example, to disable a particular REST API endpoint, you could just remove the registration of that endpoint from within the src/butler.js file.", 
            "title": "Customisation"
        }, 
        {
            "location": "/running/", 
            "text": "Running Butler\n\n\nThe easiest way of starting Butler is by using the normal node.js way of starting node apps:\n\n\nd:\ncd \\node\\butler\\src\nnode butler.js\n\n\n\nIt is of course also possible to put those commands in a .bat file and execute that file instead.  \n\n\nProcess monitors\n\n\nAs Butler is the kind of service that (probably) should always be running on a server, it makes sense using a node.js process monitor to keep it alive.\n\n\nPM2\n and \nForever\n are two process monitors that both have been successfully tested with Butler.  \n\n\nOne caveat with these is that it is hard to start them (and thus Butler) when a Windows server is rebooted.\nPM2 can be used to solve this challenge in a nice way, more info in \nthis blog post\n.", 
            "title": "Running Butler"
        }, 
        {
            "location": "/running/#running_butler", 
            "text": "The easiest way of starting Butler is by using the normal node.js way of starting node apps:  d:\ncd \\node\\butler\\src\nnode butler.js  It is of course also possible to put those commands in a .bat file and execute that file instead.", 
            "title": "Running Butler"
        }, 
        {
            "location": "/running/#process_monitors", 
            "text": "As Butler is the kind of service that (probably) should always be running on a server, it makes sense using a node.js process monitor to keep it alive.  PM2  and  Forever  are two process monitors that both have been successfully tested with Butler.    One caveat with these is that it is hard to start them (and thus Butler) when a Windows server is rebooted.\nPM2 can be used to solve this challenge in a nice way, more info in  this blog post .", 
            "title": "Process monitors"
        }, 
        {
            "location": "/rest/", 
            "text": "REST API\n\n\nButler's \nREST API\n serves several purposes. \n\nThe main purpose of Butler's REST API is to allow various tasks to be carried out/started from a Sense load script, but the REST API can also be used by external systems (outside of the Sense environment) to communicate with Sense. The main areas are:  \n\n\n\n\n\n\nProvide convenient and easy access to select Sense APIs\n \n\nButler handles all authentication needed to talk to the Sense APIs, as well as combining multiple calls to Sense APIs, offering more high level features than those offered by Sense natively.\n\n\n\n\n\n\nStart Sense tasks\n\nExternal systems (outside of Sense) can trigger Sense tasks (e.g. reload tasks). This way a database can trigger an app reload when new data is available in the database. Or a Sense load script can trigger other tasks when the execution of the script reaches certain points in the script.\n\n\n\n\n\n\nSend MQTT messages\n\nButler enables Sense load scripts to send \nMQTT\n messages. MQTT is a very stable and widely adopted \nm2m communication\n protocol, with client libraries available in many different languages.\n\n\n\n\n\n\nStart Sense tasks when MQTT messages arrive\n \n\nButler subscribes to a certain (configurable) MQTT topic, and starts Sense tasks based on messages received in that topic.\n\n\n\n\n\n\nSend messages to Slack and other 3rd party services\n \n\nIntegrating \nSlack\n with Sense has proven extremely useful. \n\nFrom within a Sense load script it is possible to write progress info for long running reloads to Slack, notifying users that a reload has finished, notifying sysadmins that a reload has encountered some error condition etc.\n\nAs Slack works really well across both desktop and mobile devices, Sense will benefit that cross platform feature too.  \n\n\n\n\n\n\nThe Slack integration supports Slack's full markdown message formatting as well as \nemoijs\n.\n\n\nVersioning of the REST API\n\n\nThis is a very wide and complex topic in itself.\n\nFor now Butler uses a very simple and rather naive approach, by just prefixing the endpoint name with a version number, e.g. http://FQDN/v2/EndpointName/... \n\nThis allows Butler to support multiple versions, and old versions to be (possibly) deprecated in the future.\n\n\nREST API endpoints\n\n\n/v2/activeUserCount\n\n\n  Purpose    : Get number of users that have active sessions. This value is based on session start/stop events, which means that there are corner cases where the incorrect value will be shown - for example just after starting Butler.  \n  Parameters : -\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/activeUserCount\n  Returns    : 5\n\n\n\n/v2/activeUsers\n\n\n  Purpose    : Get an arrary with the usernames of users that currently have active sessions. This endpoint suffers from same limitation as the activeUserCount endpoint, i.e. it will not capture sessions that are active when Butler is started.  \n  Parameters : -\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/activeUsers\n  Returns    : [\"userA\",\"userB\",\"userC\"]\n\n\n\n/v2/base16ToBase62\n\n\n  Purpose    : Convert a value coded in base16 to a base62 value. Works on arbitrary length input strings.  \n  Parameters : base16\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/base16ToBase62?base16=1f5848b5f8ba4e85a57c7ca55a9e\n  Returns    : 3t5Na7R7Hj5yaBCv80S\n\n\n\n/v2/base62ToBase16\n\n\n  Purpose    : Convert a value coded in base62 to a base16 value. Works on arbitrary length input strings.  \n  Parameters : base62\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/base62ToBase16?base62=0X96HlegVXzQfJVIBWC31\n  Returns    : 816c8710661a0a69e51ac8dc4ccf13\n\n\n\n/v2/butlerPing\n\n\n  Purpose    : Ask Butler if it is running and all is ok.\n  Parameters : -\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/butlerPing\n  Returns    : {\"response\":\"Butler reporting for duty\"}\n\n\n\n/v2/createDir\n\n\n  Purpose    : Create a directory in any place (where the account Butler is running under has write access) on the server.  \n               Intermediate directories will be created too, i.e. if creating d:\\abc\\def when d:\\abc does net yet exist, it will also be created.\n  Parameters : directory\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/createDir?directory=d:/abc/def\n  Returns    : {\"directory\":\"d:/abc/def\"}\n\n\n\n/v2/createDirQVD\n\n\n  Purpose    : Create a directory relative to a predefined path. Can be used to ensure all QVDs are stored in a well defined location.\n               Intermediate directories will be created too, i.e. if creating d:\\abc\\def when d:\\abc does net yet exist, it will also be created.\n  Parameters : directory\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/createDirQVD?directory=abc/def\n  Returns    : {\"directory\":\"abc/def\"}\n\n\n\n/v2/mqttPublishMessage\n\n\n  Purpose    : Publish a message to a MQTT topic, using a MQTT broker defined in the Butler config file\n  Parameters : topic, message\n  Example    : curl \"http://\nFQDN or IP of Butler\n:8080/v2/mqttPublishMessage?topic=abc/def\nmessage=ButlerTalksMQTT\"\n               curl -G \"http://\nFQDN or IP of Butler\n:8080/v2/mqttPublishMessage\" --data-urlencode \"topic=abc/def\" --data-urlencode \"message=Butler talks MQTT\"\n  Returns    : {\"topic\":\"abc/def\",\"message\":\"ButlerTalksMQTT\"}\n               {\"topic\":\"abc/def\",\"message\":\"Butler talks MQTT\"}\n\n\n\n/v2/senseAppDump\n\n\n  Purpose    : Extracts metadata about a Sense app.\n  Parameters : appId\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/senseAppDump?appId=98765e52-abcd-1234-5678-5678203b23b3\n  Returns    : A long, long JSON string.\n\n\n\n/v2/senseListApps\n\n\n  Purpose    : List name and GUID of all apps in the Sense cluster where Butler is installed.\n  Parameters : -\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/senseListApps\n  Returns    : A long, long JSON string.\n\n\n\n/v2/senseStartTask\n\n\n  Purpose    : Start a Sense task. Can be used by upstream data providers to trigger reloads of Sense apps when new data is available.\n  Parameters : taskId\n  Example    : curl http://\nFQDN or IP of Butler\n:8080/v2/senseStartTask?taskId=abcd1234-5678-abcd-1234-abcd1234abcd\n  Returns    : {\"taskId\":\"abcd1234-5678-abcd-1234-abcd1234abcd\"}\n\n\n\n/v2/slackPostMessage\n\n\n  Purpose    : Post a message to a Slack channel. Normal Slack formatting options (emoijs, markdown etc) can be used.\n  Parameters : channel, from_user, msg, emoij\n  Example    : curl -G http://\nFQDN or IP of Butler\n:8080/v2/slackPostMessage --data-urlencode \"channel=#sense-test-slack\" --data-urlencode \"msg=Butler posting to *Slack*\" --data-urlencode \"from_user=sa_scheduler\" --data-urlencode \"emoji=:test:\"\n  Returns    : {\"channel\":\"#sense-test-slack\",\"msg\":\"Butler posting to *Slack*\",\"from_user\":\"sa_scheduler\",\"emoji\":\":test:\"}", 
            "title": "REST API"
        }, 
        {
            "location": "/rest/#rest_api", 
            "text": "Butler's  REST API  serves several purposes.  \nThe main purpose of Butler's REST API is to allow various tasks to be carried out/started from a Sense load script, but the REST API can also be used by external systems (outside of the Sense environment) to communicate with Sense. The main areas are:      Provide convenient and easy access to select Sense APIs   \nButler handles all authentication needed to talk to the Sense APIs, as well as combining multiple calls to Sense APIs, offering more high level features than those offered by Sense natively.    Start Sense tasks \nExternal systems (outside of Sense) can trigger Sense tasks (e.g. reload tasks). This way a database can trigger an app reload when new data is available in the database. Or a Sense load script can trigger other tasks when the execution of the script reaches certain points in the script.    Send MQTT messages \nButler enables Sense load scripts to send  MQTT  messages. MQTT is a very stable and widely adopted  m2m communication  protocol, with client libraries available in many different languages.    Start Sense tasks when MQTT messages arrive   \nButler subscribes to a certain (configurable) MQTT topic, and starts Sense tasks based on messages received in that topic.    Send messages to Slack and other 3rd party services   \nIntegrating  Slack  with Sense has proven extremely useful.  \nFrom within a Sense load script it is possible to write progress info for long running reloads to Slack, notifying users that a reload has finished, notifying sysadmins that a reload has encountered some error condition etc. \nAs Slack works really well across both desktop and mobile devices, Sense will benefit that cross platform feature too.      The Slack integration supports Slack's full markdown message formatting as well as  emoijs .", 
            "title": "REST API"
        }, 
        {
            "location": "/rest/#versioning_of_the_rest_api", 
            "text": "This is a very wide and complex topic in itself. \nFor now Butler uses a very simple and rather naive approach, by just prefixing the endpoint name with a version number, e.g. http://FQDN/v2/EndpointName/...  \nThis allows Butler to support multiple versions, and old versions to be (possibly) deprecated in the future.", 
            "title": "Versioning of the REST API"
        }, 
        {
            "location": "/rest/#rest_api_endpoints", 
            "text": "", 
            "title": "REST API endpoints"
        }, 
        {
            "location": "/rest/#v2activeusercount", 
            "text": "Purpose    : Get number of users that have active sessions. This value is based on session start/stop events, which means that there are corner cases where the incorrect value will be shown - for example just after starting Butler.  \n  Parameters : -\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/activeUserCount\n  Returns    : 5", 
            "title": "/v2/activeUserCount"
        }, 
        {
            "location": "/rest/#v2activeusers", 
            "text": "Purpose    : Get an arrary with the usernames of users that currently have active sessions. This endpoint suffers from same limitation as the activeUserCount endpoint, i.e. it will not capture sessions that are active when Butler is started.  \n  Parameters : -\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/activeUsers\n  Returns    : [\"userA\",\"userB\",\"userC\"]", 
            "title": "/v2/activeUsers"
        }, 
        {
            "location": "/rest/#v2base16tobase62", 
            "text": "Purpose    : Convert a value coded in base16 to a base62 value. Works on arbitrary length input strings.  \n  Parameters : base16\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/base16ToBase62?base16=1f5848b5f8ba4e85a57c7ca55a9e\n  Returns    : 3t5Na7R7Hj5yaBCv80S", 
            "title": "/v2/base16ToBase62"
        }, 
        {
            "location": "/rest/#v2base62tobase16", 
            "text": "Purpose    : Convert a value coded in base62 to a base16 value. Works on arbitrary length input strings.  \n  Parameters : base62\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/base62ToBase16?base62=0X96HlegVXzQfJVIBWC31\n  Returns    : 816c8710661a0a69e51ac8dc4ccf13", 
            "title": "/v2/base62ToBase16"
        }, 
        {
            "location": "/rest/#v2butlerping", 
            "text": "Purpose    : Ask Butler if it is running and all is ok.\n  Parameters : -\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/butlerPing\n  Returns    : {\"response\":\"Butler reporting for duty\"}", 
            "title": "/v2/butlerPing"
        }, 
        {
            "location": "/rest/#v2createdir", 
            "text": "Purpose    : Create a directory in any place (where the account Butler is running under has write access) on the server.  \n               Intermediate directories will be created too, i.e. if creating d:\\abc\\def when d:\\abc does net yet exist, it will also be created.\n  Parameters : directory\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/createDir?directory=d:/abc/def\n  Returns    : {\"directory\":\"d:/abc/def\"}", 
            "title": "/v2/createDir"
        }, 
        {
            "location": "/rest/#v2createdirqvd", 
            "text": "Purpose    : Create a directory relative to a predefined path. Can be used to ensure all QVDs are stored in a well defined location.\n               Intermediate directories will be created too, i.e. if creating d:\\abc\\def when d:\\abc does net yet exist, it will also be created.\n  Parameters : directory\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/createDirQVD?directory=abc/def\n  Returns    : {\"directory\":\"abc/def\"}", 
            "title": "/v2/createDirQVD"
        }, 
        {
            "location": "/rest/#v2mqttpublishmessage", 
            "text": "Purpose    : Publish a message to a MQTT topic, using a MQTT broker defined in the Butler config file\n  Parameters : topic, message\n  Example    : curl \"http:// FQDN or IP of Butler :8080/v2/mqttPublishMessage?topic=abc/def message=ButlerTalksMQTT\"\n               curl -G \"http:// FQDN or IP of Butler :8080/v2/mqttPublishMessage\" --data-urlencode \"topic=abc/def\" --data-urlencode \"message=Butler talks MQTT\"\n  Returns    : {\"topic\":\"abc/def\",\"message\":\"ButlerTalksMQTT\"}\n               {\"topic\":\"abc/def\",\"message\":\"Butler talks MQTT\"}", 
            "title": "/v2/mqttPublishMessage"
        }, 
        {
            "location": "/rest/#v2senseappdump", 
            "text": "Purpose    : Extracts metadata about a Sense app.\n  Parameters : appId\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/senseAppDump?appId=98765e52-abcd-1234-5678-5678203b23b3\n  Returns    : A long, long JSON string.", 
            "title": "/v2/senseAppDump"
        }, 
        {
            "location": "/rest/#v2senselistapps", 
            "text": "Purpose    : List name and GUID of all apps in the Sense cluster where Butler is installed.\n  Parameters : -\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/senseListApps\n  Returns    : A long, long JSON string.", 
            "title": "/v2/senseListApps"
        }, 
        {
            "location": "/rest/#v2sensestarttask", 
            "text": "Purpose    : Start a Sense task. Can be used by upstream data providers to trigger reloads of Sense apps when new data is available.\n  Parameters : taskId\n  Example    : curl http:// FQDN or IP of Butler :8080/v2/senseStartTask?taskId=abcd1234-5678-abcd-1234-abcd1234abcd\n  Returns    : {\"taskId\":\"abcd1234-5678-abcd-1234-abcd1234abcd\"}", 
            "title": "/v2/senseStartTask"
        }, 
        {
            "location": "/rest/#v2slackpostmessage", 
            "text": "Purpose    : Post a message to a Slack channel. Normal Slack formatting options (emoijs, markdown etc) can be used.\n  Parameters : channel, from_user, msg, emoij\n  Example    : curl -G http:// FQDN or IP of Butler :8080/v2/slackPostMessage --data-urlencode \"channel=#sense-test-slack\" --data-urlencode \"msg=Butler posting to *Slack*\" --data-urlencode \"from_user=sa_scheduler\" --data-urlencode \"emoji=:test:\"\n  Returns    : {\"channel\":\"#sense-test-slack\",\"msg\":\"Butler posting to *Slack*\",\"from_user\":\"sa_scheduler\",\"emoji\":\":test:\"}", 
            "title": "/v2/slackPostMessage"
        }, 
        {
            "location": "/log-events/", 
            "text": "Creating log4net appenders\n\n\nSense uses the \nApache log4net logging framework\n. It is used to write all the log files found in the C:\\ProgramData\\Qlik\\Sense\\Log directory tree.\n\nlog4net is extensible in that you can hook in your own event handlers, and in this way get notifications. \n\n\nQlik provides basic \ndocumentation\n for this, unfortunately a lot of trial and error is usually needed when crating new XML files that will be hooked into the framework.\n\n\nA couple of custom appenders (in the form of XML files) are included with Butler, these are described below.\n\n\nSession start/stop, connection open/close\n\n\nIn the \nlog4net_user-audit-event\n folder in the Butler repository there is an XML file that will send a UDP message on port 9997 to Butler when any of the following events occur:\n\n\n\n\nSession start\n: When a user logs into Sense and do not have Sense open in any other window or tab in the browser. \n\n\nSession end\n: When a user has not been active for a while, and the session timeout is reached.\n\n\nConnection open\n: When a user open a new app, or do a browser refresh of a Sense app\n\n\nConnection close\n: When a user closes a browser window or tab, in which a Sense app was open\n\n\n\n\nUsually the UDP message is sent very quickly, typically within a second of the app being opened or close, for example.\n\nThe message contains this information: \n\n\n%hostname;%property{Command};%property{UserDirectory};%property{UserId}\n\n\n\nI.e. the information sent to Butler is  \n\n\n\n\nServer name where the log message originated\n\n\nWhat command is associated with the message (session start/stop, connection open/close)\n\n\nWhat Sense user directory the associated user belongs to\n\n\nThe username of the associated user.\n\n\n\n\nThe UDP server built into Butler will then extract the data and take several actions, exactly which depending on what event was received.\n\n\nSession start\n\n\nThe following actions are taken\n\n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting.\n\n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.sessionStartTopic configuration setting.  \n\n\nSession stop\n\n\nThe following actions are taken\n\n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting.\n\n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.sessionStopTopic configuration setting.  \n\n\nConnection open\n\n\nThe following actions are taken\n\n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting.\n\n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.connectionOpenTopic configuration setting.  \n\n\nConnection close\n\n\nThe following actions are taken\n\n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting.\n\n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.connectionCloseTopic configuration setting.  \n\n\nExamples on how the Slack messages will look can be found on the \nUDP client page\n. \n\n\nTask reload errors\n\n\nIn the \nlog4net_task-failed\n folder in the Butler repository there is an XML file that will send a UDP message on port 9998 to Butler when any of the following events occur:\n\n\n\n\nTask failing\n: When a Sense task, started by the Sense scheduler, for some reason fails, the XML file make a couple of UDP messages (with slightly different contents) to be sent to Butler. Manually started reloads (from the script editor) that fail will not generate these events.\n\n\n\n\nThe message contains this information: \n\n\n%hostname;%property{TaskName};%property{AppName};%property{UserId}\n\n\n\nI.e. the information sent to Butler is  \n\n\n\n\nServer name where the log message originated\n\n\nName of the task\n\n\nName of the app that the task is associated with\n\n\nUsername of the user running the task.\n\n\n\n\nThe UDP server built into Butler will then extract the data and take several actions, exactly which depending on what event was received.\n\n\nFailing task\n\n\nThe following actions are taken\n\n1. Posts the event data to Slack, using the Butler.slackConfig.taskFailureTopic configuration setting.\n\n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.taskFailureTopic configuration setting.  \n\n\nExamples on how the Slack messages will look can be found on the \nUDP client page\n.", 
            "title": "Log event handlers"
        }, 
        {
            "location": "/log-events/#creating_log4net_appenders", 
            "text": "Sense uses the  Apache log4net logging framework . It is used to write all the log files found in the C:\\ProgramData\\Qlik\\Sense\\Log directory tree. \nlog4net is extensible in that you can hook in your own event handlers, and in this way get notifications.   Qlik provides basic  documentation  for this, unfortunately a lot of trial and error is usually needed when crating new XML files that will be hooked into the framework.  A couple of custom appenders (in the form of XML files) are included with Butler, these are described below.", 
            "title": "Creating log4net appenders"
        }, 
        {
            "location": "/log-events/#session_startstop_connection_openclose", 
            "text": "In the  log4net_user-audit-event  folder in the Butler repository there is an XML file that will send a UDP message on port 9997 to Butler when any of the following events occur:   Session start : When a user logs into Sense and do not have Sense open in any other window or tab in the browser.   Session end : When a user has not been active for a while, and the session timeout is reached.  Connection open : When a user open a new app, or do a browser refresh of a Sense app  Connection close : When a user closes a browser window or tab, in which a Sense app was open   Usually the UDP message is sent very quickly, typically within a second of the app being opened or close, for example. \nThe message contains this information:   %hostname;%property{Command};%property{UserDirectory};%property{UserId}  I.e. the information sent to Butler is     Server name where the log message originated  What command is associated with the message (session start/stop, connection open/close)  What Sense user directory the associated user belongs to  The username of the associated user.   The UDP server built into Butler will then extract the data and take several actions, exactly which depending on what event was received.", 
            "title": "Session start/stop, connection open/close"
        }, 
        {
            "location": "/log-events/#session_start", 
            "text": "The following actions are taken \n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting. \n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.sessionStartTopic configuration setting.", 
            "title": "Session start"
        }, 
        {
            "location": "/log-events/#session_stop", 
            "text": "The following actions are taken \n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting. \n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.sessionStopTopic configuration setting.", 
            "title": "Session stop"
        }, 
        {
            "location": "/log-events/#connection_open", 
            "text": "The following actions are taken \n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting. \n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.connectionOpenTopic configuration setting.", 
            "title": "Connection open"
        }, 
        {
            "location": "/log-events/#connection_close", 
            "text": "The following actions are taken \n1. Posts the event data to Slack, using the Butler.slackConfig.loginNotificationChannel configuration setting. \n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.connectionCloseTopic configuration setting.    Examples on how the Slack messages will look can be found on the  UDP client page .", 
            "title": "Connection close"
        }, 
        {
            "location": "/log-events/#task_reload_errors", 
            "text": "In the  log4net_task-failed  folder in the Butler repository there is an XML file that will send a UDP message on port 9998 to Butler when any of the following events occur:   Task failing : When a Sense task, started by the Sense scheduler, for some reason fails, the XML file make a couple of UDP messages (with slightly different contents) to be sent to Butler. Manually started reloads (from the script editor) that fail will not generate these events.   The message contains this information:   %hostname;%property{TaskName};%property{AppName};%property{UserId}  I.e. the information sent to Butler is     Server name where the log message originated  Name of the task  Name of the app that the task is associated with  Username of the user running the task.   The UDP server built into Butler will then extract the data and take several actions, exactly which depending on what event was received.", 
            "title": "Task reload errors"
        }, 
        {
            "location": "/log-events/#failing_task", 
            "text": "The following actions are taken \n1. Posts the event data to Slack, using the Butler.slackConfig.taskFailureTopic configuration setting. \n2. Publish a message to MQTT, in the topic defined in the Butler.mqttConfig.taskFailureTopic configuration setting.    Examples on how the Slack messages will look can be found on the  UDP client page .", 
            "title": "Failing task"
        }, 
        {
            "location": "/real-time/", 
            "text": "Real time data on active user sessions\n\n\nButler listens to session start/end messages from Sense's log4net logging framework, and keeps records of both how many and which users currently have active sessions.\n\nIdeal would be if the Sense APIs would provide a list of currently active users, that us however currently not available. \nFor that reason Butler's tactic is to listen to log events to determine when users start and end sessions.   \n\n\nThere is however a downside to this approach.\n\nWhen Butler is first started, it will not know what sessions are currently active. Instead, it will collect that inforamation as time passes.\n\nThis means that the active user count, as well as what specific users are active, might be incorrect when Butler is first started. \nThe data will then become more and more exact as users end their sessions, and later restart them (Butler will then capture the session restart, and update its data structures accordingly).\n\n\nIf there are demands for enterprise grade monitoring of a Qlik Sense environment, the \nButler SOS\n tool focuses exclusively on this and might be worth looking into.\n\n\nActive users data as MQTT messages\n\n\nButler publishes a set of MQTT messages relating to active sessions.\n\nWhenever a session starts or ends, two MQT messages will be sent:  \n\n\n\n\nThe new number for number of active user sessions is posted to the MQTT topic defined by the config entry Butler.mqttConfig.activeUserCountTopic\n\n\nA string array with usernames of all users with active sessions is posted to MQTT topic defined by Butler.mqttConfig.activeUsersTopic\n\n\n\n\nMaking this data available as MQTT messages, it can then be used in real-time dashboards or for alerting purposes.\n\nFor example, using \nNode-RED's dashboard module\n, it is trivial to create a real-time updating dashboard like this one (showing data for the last few days):", 
            "title": "Real time metrics"
        }, 
        {
            "location": "/real-time/#real_time_data_on_active_user_sessions", 
            "text": "Butler listens to session start/end messages from Sense's log4net logging framework, and keeps records of both how many and which users currently have active sessions. \nIdeal would be if the Sense APIs would provide a list of currently active users, that us however currently not available. \nFor that reason Butler's tactic is to listen to log events to determine when users start and end sessions.     There is however a downside to this approach. \nWhen Butler is first started, it will not know what sessions are currently active. Instead, it will collect that inforamation as time passes. \nThis means that the active user count, as well as what specific users are active, might be incorrect when Butler is first started. \nThe data will then become more and more exact as users end their sessions, and later restart them (Butler will then capture the session restart, and update its data structures accordingly).  If there are demands for enterprise grade monitoring of a Qlik Sense environment, the  Butler SOS  tool focuses exclusively on this and might be worth looking into.", 
            "title": "Real time data on active user sessions"
        }, 
        {
            "location": "/real-time/#active_users_data_as_mqtt_messages", 
            "text": "Butler publishes a set of MQTT messages relating to active sessions. \nWhenever a session starts or ends, two MQT messages will be sent:     The new number for number of active user sessions is posted to the MQTT topic defined by the config entry Butler.mqttConfig.activeUserCountTopic  A string array with usernames of all users with active sessions is posted to MQTT topic defined by Butler.mqttConfig.activeUsersTopic   Making this data available as MQTT messages, it can then be used in real-time dashboards or for alerting purposes. \nFor example, using  Node-RED's dashboard module , it is trivial to create a real-time updating dashboard like this one (showing data for the last few days):", 
            "title": "Active users data as MQTT messages"
        }, 
        {
            "location": "/mqtt/", 
            "text": "MQTT\n\n\nMQTT\n is a light weight publish-subscribe (\"pub-sub\") protocol.\n\nPopular in use in Internet of Things applications, there are client libraries available for many different languages and platforms. This is important, as there is a good chance other systems can find a way of sending MQTT messages, which Butler can then listen for/subscribe to.\n\n\nOutgoing MQTT - publish\n\n\nButler can post messages to MQTT topics. The \n/mqqtPublishMessage\n is used to achieve this.\n\nThis way Butler can send status information and notifications to other systems, outside of Qlik Sense. Use cases include: \n\n\n\n\nNotify downstream systems that Sense has finished creating some data set that the downstream system is depending on.\n\n\nSend debug or trace messages to MQTT instead of to the Sense log. Using a MQTT client (there are multiple ones on both Windows, OSX and Linux) you can the monitor the messages in real time. Very useful during development of tricky Sense load scripts!\n\n\nStart Sense tasks (typically reloads) from the Sense load script. Very useful when you need to trigger a second app reload once the first app's load script reaches some specific point of execution.\n\nThis way the scheduling and execution of Sense tasks can be made much more flexible than using the built in QMC scheduler.\n\n\nSend messages to platforms such as Node-RED. Node-RED is an open source platform (with a graphical editor) intended for integrating different systems and data sources. As it is built on node.red there are many different modules available, offering integrations with all sorts of systems and protocols.\n\nUsing Node.RED together with Qlik Sense and Butler, it is possible to interface with social media from the Sense load script (send a Tweet when some condition occur during app reload, for example).\n\n\n\n\nIncoming MQTT - subscribe\n\n\nButler listens to all MQTT messages in the qliksense/# topic tree. Which in MQTT lingo means \"listen to all messages in the qliksense topic, as well as in any subtopics\".\n\nWhen Butler finds such a message, it is analysed and if the topic matches any of the predefined topics with special meaning, the associated tasks are carried out.  \n\n\nTopics with special meaning are:\n\n\n\n\nqliksense/start_task\n: Starts the Sense task identified by the ID sent in the message body. See the \nExamples\n secion.\n\n\n\n\nAs Butler listens to all messages in qliksense/#, it can easily be extended with handlers for additional topics.", 
            "title": "MQTT integration"
        }, 
        {
            "location": "/mqtt/#mqtt", 
            "text": "MQTT  is a light weight publish-subscribe (\"pub-sub\") protocol. \nPopular in use in Internet of Things applications, there are client libraries available for many different languages and platforms. This is important, as there is a good chance other systems can find a way of sending MQTT messages, which Butler can then listen for/subscribe to.", 
            "title": "MQTT"
        }, 
        {
            "location": "/mqtt/#outgoing_mqtt_-_publish", 
            "text": "Butler can post messages to MQTT topics. The  /mqqtPublishMessage  is used to achieve this. \nThis way Butler can send status information and notifications to other systems, outside of Qlik Sense. Use cases include:    Notify downstream systems that Sense has finished creating some data set that the downstream system is depending on.  Send debug or trace messages to MQTT instead of to the Sense log. Using a MQTT client (there are multiple ones on both Windows, OSX and Linux) you can the monitor the messages in real time. Very useful during development of tricky Sense load scripts!  Start Sense tasks (typically reloads) from the Sense load script. Very useful when you need to trigger a second app reload once the first app's load script reaches some specific point of execution. \nThis way the scheduling and execution of Sense tasks can be made much more flexible than using the built in QMC scheduler.  Send messages to platforms such as Node-RED. Node-RED is an open source platform (with a graphical editor) intended for integrating different systems and data sources. As it is built on node.red there are many different modules available, offering integrations with all sorts of systems and protocols. \nUsing Node.RED together with Qlik Sense and Butler, it is possible to interface with social media from the Sense load script (send a Tweet when some condition occur during app reload, for example).", 
            "title": "Outgoing MQTT - publish"
        }, 
        {
            "location": "/mqtt/#incoming_mqtt_-_subscribe", 
            "text": "Butler listens to all MQTT messages in the qliksense/# topic tree. Which in MQTT lingo means \"listen to all messages in the qliksense topic, as well as in any subtopics\". \nWhen Butler finds such a message, it is analysed and if the topic matches any of the predefined topics with special meaning, the associated tasks are carried out.    Topics with special meaning are:   qliksense/start_task : Starts the Sense task identified by the ID sent in the message body. See the  Examples  secion.   As Butler listens to all messages in qliksense/#, it can easily be extended with handlers for additional topics.", 
            "title": "Incoming MQTT - subscribe"
        }, 
        {
            "location": "/udp-client/", 
            "text": "UDP client\n\n\nButler includes a very basic UDP client, which can be used to send test messages to Butler's UDP servers.\n\nThis can be useful when debugging a Butler server, when adding new UDP handlers etc. \nThe client is built using node.js, and is found in the src/udp_client directory.\n\n\nRun the app to show its help text (in this case the UDP client is executed from a Mac):\n\n\n$ node udp_client.js\nUsage: node udp_client.js [options]\n\nThis app sends messages to the UDP server(s) built into Butler (or any other UDP\nserver)\n\nOptions:\n  --version   Show version number                                      [boolean]\n  -i, --ip    IP address of UDP server message will be sent to        [required]\n  -p, --port  Port on UDP server                                      [required]\n  -m, --msg   Message to send                          [default: \"Test message\"]\n  -h, --help  Show help                                                [boolean]\n\nMissing required arguments: i, p\n$\n\n\n\nTesting the session start/stop, connection open/close UDP server\n\n\nSending a message to Butler looks like this (with a fake IP address):\n\n\n$ node udp_client.js --ip 1.2.3.4 -p 9997 -m \"Abc;123;456;test\"\nUDP message sent to 1.2.3.4:9997, 16 bytes.\n$\n\n\n\nButler will receive the message, parse it, and a) send a message to a Slack channel (customizable in the \nButler config file\n), \nand b) publish a MQTT message to the topic specified in, again, the Butler config file.\n\n\nThe output to Slack looks like this (the default use of port 9997 is to handle audit events, i.e. users starting/ending sessions etc):   \n\n\n\n\nTesting the failed task UDP server\n\n\nSending a message to port 9998 will test the UDP server responsible for handling task failure messages:\n\n\nSending a message to Butler looks like this (with a fake IP address):\n\n\n$ node udp_client.js --ip 1.2.3.4 -p 9998 -m \"Abc;123;456;test\"\nUDP message sent to 1.2.3.4:9998, 16 bytes.\n$\n\n\n\nThe resulting Slack message looks like this:", 
            "title": "UDP client"
        }, 
        {
            "location": "/udp-client/#udp_client", 
            "text": "Butler includes a very basic UDP client, which can be used to send test messages to Butler's UDP servers. \nThis can be useful when debugging a Butler server, when adding new UDP handlers etc. \nThe client is built using node.js, and is found in the src/udp_client directory.  Run the app to show its help text (in this case the UDP client is executed from a Mac):  $ node udp_client.js\nUsage: node udp_client.js [options]\n\nThis app sends messages to the UDP server(s) built into Butler (or any other UDP\nserver)\n\nOptions:\n  --version   Show version number                                      [boolean]\n  -i, --ip    IP address of UDP server message will be sent to        [required]\n  -p, --port  Port on UDP server                                      [required]\n  -m, --msg   Message to send                          [default: \"Test message\"]\n  -h, --help  Show help                                                [boolean]\n\nMissing required arguments: i, p\n$", 
            "title": "UDP client"
        }, 
        {
            "location": "/udp-client/#testing_the_session_startstop_connection_openclose_udp_server", 
            "text": "Sending a message to Butler looks like this (with a fake IP address):  $ node udp_client.js --ip 1.2.3.4 -p 9997 -m \"Abc;123;456;test\"\nUDP message sent to 1.2.3.4:9997, 16 bytes.\n$  Butler will receive the message, parse it, and a) send a message to a Slack channel (customizable in the  Butler config file ), \nand b) publish a MQTT message to the topic specified in, again, the Butler config file.  The output to Slack looks like this (the default use of port 9997 is to handle audit events, i.e. users starting/ending sessions etc):", 
            "title": "Testing the session start/stop, connection open/close UDP server"
        }, 
        {
            "location": "/udp-client/#testing_the_failed_task_udp_server", 
            "text": "Sending a message to port 9998 will test the UDP server responsible for handling task failure messages:  Sending a message to Butler looks like this (with a fake IP address):  $ node udp_client.js --ip 1.2.3.4 -p 9998 -m \"Abc;123;456;test\"\nUDP message sent to 1.2.3.4:9998, 16 bytes.\n$  The resulting Slack message looks like this:", 
            "title": "Testing the failed task UDP server"
        }, 
        {
            "location": "/sample-code/", 
            "text": "Examples on how to use Butler\n\n\nCall Butler REST endpoints from within Sense load scripts\n\n\nWhile it is quite possible to call the Butler REST endpoints directly from a LOAD...FROM statement, it is usually more convenient to use the subroutine wrappers that are available as .qvs files in the sense_script folder in the Butler repository.\n\n\nBefore doing any calls to Butler, we should initialize things. Failing to do so might lead to errors and unpredictable responses from the Butler APIs.    \n\n\n$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\nCALL ButlerInit;\n\n\n\nNote:  \n\n\n\n\nWe first include the subroutine from a .qvs file, then call it. The same concept is used throughout Butler when it comes to making use of Butler features from the Sense load script.\n\n\nThe Butler qvs files are stored in a folder on the Sense server, which is linked to a data connection called \"Butler scripts\".  \n\n\n\n\nWith this taken care of, we can call any other Butler API.\n\n\nPosting to Slack\n\n\n$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/post_to_slack.qvs]);\n\nCALL ButlerInit;\nCALL PostToSlack('sense-reload-info', 'server: senseServer1', '*\nApp name\n*: reload starting', ':ghost:');  // Post a starting message to Slack\nCALL PostToSlack('sense-reload-info', subfield(OSUser(),'UserId=',2) \n ' on server: ' \n ComputerName(), '*Reloaded by: ' \n subfield(OSUser(),'UserId=',2) \n '* \nApp name\n: Reload starting', ':test:');\n\n\n\nThis will result in the following Slack entries:\n\n\n\n\n  \n\n\nStart a Sense task\n\n\n$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/start_task.qvs]);\n\nCALL ButlerInit;\nCALL StartTask('abcd1234-5678-abcd-1234-abcd1234abcd');     // Parameter should be ID of the task that is to be started\n\n\n\nPost a message to an MQTT topic\n\n\n$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/post_to_slack.qvs]);\n\nCALL ButlerInit;\nCALL PostToMQTT('qliksense/myapp/reload_status', 'starting');   // Posting message \"starting\" to topic \"qliksense/myapp/reload_status\"\n\n\n\nCreate a directory on disk\n\n\n$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/create_directory.qvs]);\n\nCALL ButlerInit;\nCALL CreateDir('d:/abc/def/ghi');       // Note that forward slashes work\nCALL CreateDir('d:\\123\\456\\789');       // Backslashes work too\n\n\n\nList all Sense apps on the server\n\n\n// \"Sense list apps\" is a data connection using Qlik's standard REST connector, connected \n// to http://\nFQDN or IP of Butler server\n:8080/senseListApps\n// The Apps table will contain id and name of all apps on the server\n\nLIB CONNECT TO 'Sense list apps';\n\nRestConnectorMasterTable:\nSQL SELECT \n    \"id\",\n    \"name\"\nFROM JSON (wrap on) \"root\";\n\nApps:\nLOAD    \n    [id]    AS [App id],\n    [name]  AS [App name]\nRESIDENT RestConnectorMasterTable;\n\nDROP TABLE RestConnectorMasterTable;\n\n\n\nSerialise a Sense app to JSON and a Sense data model\n\n\nCreate a data connection (for example called \"Sense app extract\") using Qlik's REST connector, against http://\n:8080/senseAppDump\nThis will generate several thousands lines of code in the Sense script editor, modelling a Sense app's internal data model. \nThe Butler endpoint returns a JSON, which the REST connector then transforms into a Sense data model.\nTo dynamically control which app is serialized you can use the \"with connection\" syntax.\n\n\nLIB CONNECT TO 'Sense app extract';\n\nlet vAppId = 'abcd1234-5678-abcd-1234-abcd1234abcd';\n\nRestConnectorMasterTable:\nSQL SELECT \n\"loadScript\",\n...\nFROM JSON (wrap on) \"root\" PK \"__KEY_root\"\nWITH CONNECTION (\nQUERY \"guid\" \"$(vAppId)\");\n...\n\n\n\nHere is what the Sense data model can look like for a Sense app:\n\n\n  \n\n\nUse MQTT to start Sense tasks\n\n\nButler is configured to listen to a specific MQTT topic, qliksense/start_task, and use any message received in that topic as a Sense task ID, which is then started. \n\n\nFor example:  \n\n\n\n\nA Sense app, used by end users, relies on data in a MS SQL Server database.   \n\n\nThe data in the datbase can be updated at any time. \n\n\n\n\nIn order to update the Sense app with data, the most common approach is to schedule reloads of the app at certain intervals, i.e. polling the database.\n\nBut if the database instead posts a MQTT message on the qliksense/start_task topic when new data is available, the database will trigger the Sense app's reload.\n\n\nThis way the Sense app will be updated as quickly as possible after new data is availabe in the database.\n\n\nI.e. the end user will have access to more up-to-date data, compared to the polling based solution.", 
            "title": "Examples"
        }, 
        {
            "location": "/sample-code/#examples_on_how_to_use_butler", 
            "text": "", 
            "title": "Examples on how to use Butler"
        }, 
        {
            "location": "/sample-code/#call_butler_rest_endpoints_from_within_sense_load_scripts", 
            "text": "While it is quite possible to call the Butler REST endpoints directly from a LOAD...FROM statement, it is usually more convenient to use the subroutine wrappers that are available as .qvs files in the sense_script folder in the Butler repository.  Before doing any calls to Butler, we should initialize things. Failing to do so might lead to errors and unpredictable responses from the Butler APIs.      $(Must_Include=[lib://Butler scripts/butler_init.qvs]);\nCALL ButlerInit;  Note:     We first include the subroutine from a .qvs file, then call it. The same concept is used throughout Butler when it comes to making use of Butler features from the Sense load script.  The Butler qvs files are stored in a folder on the Sense server, which is linked to a data connection called \"Butler scripts\".     With this taken care of, we can call any other Butler API.", 
            "title": "Call Butler REST endpoints from within Sense load scripts"
        }, 
        {
            "location": "/sample-code/#posting_to_slack", 
            "text": "$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/post_to_slack.qvs]);\n\nCALL ButlerInit;\nCALL PostToSlack('sense-reload-info', 'server: senseServer1', '* App name *: reload starting', ':ghost:');  // Post a starting message to Slack\nCALL PostToSlack('sense-reload-info', subfield(OSUser(),'UserId=',2)   ' on server: '   ComputerName(), '*Reloaded by: '   subfield(OSUser(),'UserId=',2)   '*  App name : Reload starting', ':test:');  This will result in the following Slack entries:", 
            "title": "Posting to Slack"
        }, 
        {
            "location": "/sample-code/#start_a_sense_task", 
            "text": "$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/start_task.qvs]);\n\nCALL ButlerInit;\nCALL StartTask('abcd1234-5678-abcd-1234-abcd1234abcd');     // Parameter should be ID of the task that is to be started", 
            "title": "Start a Sense task"
        }, 
        {
            "location": "/sample-code/#post_a_message_to_an_mqtt_topic", 
            "text": "$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/post_to_slack.qvs]);\n\nCALL ButlerInit;\nCALL PostToMQTT('qliksense/myapp/reload_status', 'starting');   // Posting message \"starting\" to topic \"qliksense/myapp/reload_status\"", 
            "title": "Post a message to an MQTT topic"
        }, 
        {
            "location": "/sample-code/#create_a_directory_on_disk", 
            "text": "$(Must_Include=[lib://Butler scripts/butler_init.qvs]);\n$(Must_Include=[lib://Butler scripts/create_directory.qvs]);\n\nCALL ButlerInit;\nCALL CreateDir('d:/abc/def/ghi');       // Note that forward slashes work\nCALL CreateDir('d:\\123\\456\\789');       // Backslashes work too", 
            "title": "Create a directory on disk"
        }, 
        {
            "location": "/sample-code/#list_all_sense_apps_on_the_server", 
            "text": "// \"Sense list apps\" is a data connection using Qlik's standard REST connector, connected \n// to http:// FQDN or IP of Butler server :8080/senseListApps\n// The Apps table will contain id and name of all apps on the server\n\nLIB CONNECT TO 'Sense list apps';\n\nRestConnectorMasterTable:\nSQL SELECT \n    \"id\",\n    \"name\"\nFROM JSON (wrap on) \"root\";\n\nApps:\nLOAD    \n    [id]    AS [App id],\n    [name]  AS [App name]\nRESIDENT RestConnectorMasterTable;\n\nDROP TABLE RestConnectorMasterTable;", 
            "title": "List all Sense apps on the server"
        }, 
        {
            "location": "/sample-code/#serialise_a_sense_app_to_json_and_a_sense_data_model", 
            "text": "Create a data connection (for example called \"Sense app extract\") using Qlik's REST connector, against http:// :8080/senseAppDump\nThis will generate several thousands lines of code in the Sense script editor, modelling a Sense app's internal data model. \nThe Butler endpoint returns a JSON, which the REST connector then transforms into a Sense data model.\nTo dynamically control which app is serialized you can use the \"with connection\" syntax.  LIB CONNECT TO 'Sense app extract';\n\nlet vAppId = 'abcd1234-5678-abcd-1234-abcd1234abcd';\n\nRestConnectorMasterTable:\nSQL SELECT \n\"loadScript\",\n...\nFROM JSON (wrap on) \"root\" PK \"__KEY_root\"\nWITH CONNECTION (\nQUERY \"guid\" \"$(vAppId)\");\n...  Here is what the Sense data model can look like for a Sense app:", 
            "title": "Serialise a Sense app to JSON and a Sense data model"
        }, 
        {
            "location": "/sample-code/#use_mqtt_to_start_sense_tasks", 
            "text": "Butler is configured to listen to a specific MQTT topic, qliksense/start_task, and use any message received in that topic as a Sense task ID, which is then started.   For example:     A Sense app, used by end users, relies on data in a MS SQL Server database.     The data in the datbase can be updated at any time.    In order to update the Sense app with data, the most common approach is to schedule reloads of the app at certain intervals, i.e. polling the database. \nBut if the database instead posts a MQTT message on the qliksense/start_task topic when new data is available, the database will trigger the Sense app's reload.  This way the Sense app will be updated as quickly as possible after new data is availabe in the database.  I.e. the end user will have access to more up-to-date data, compared to the polling based solution.", 
            "title": "Use MQTT to start Sense tasks"
        }, 
        {
            "location": "/security/", 
            "text": "Security considerations\n\n\nButler uses http for its REST API. As Butler typically runs on the Sense server itself, and the firewalls of that server can be configured to protect Butler from unauthorised access, the risks can be dealt with in a reasonable way.\n\nAdding https would not be too hard though, node.js supports this very well.  \n\n\nButler uses https for all communication with Sense, using Sense's certificates for authentication. This way there is no need to set up new virtual proxies or similar in Sense.", 
            "title": "Security considerations"
        }, 
        {
            "location": "/security/#security_considerations", 
            "text": "Butler uses http for its REST API. As Butler typically runs on the Sense server itself, and the firewalls of that server can be configured to protect Butler from unauthorised access, the risks can be dealt with in a reasonable way. \nAdding https would not be too hard though, node.js supports this very well.    Butler uses https for all communication with Sense, using Sense's certificates for authentication. This way there is no need to set up new virtual proxies or similar in Sense.", 
            "title": "Security considerations"
        }, 
        {
            "location": "/tools-used/", 
            "text": "Tools used to create Butler\n\n\nBelow follows a (most likely non complete) list of tools that were used to create Butler.\n\nIt is intended to serve as a reminder to self for how to carry out various tasks, some of which may only be occasionally used.\nThus, please treat this page for what it is...\n\n\nOn a high level, Butler development is done on OSX, using \nVisual Studio Code\n.\n\n\nMkDocs\n is used to generate the documentation, which together with all files is hosted on GitHub.  \n\n\n\n\nSyntax checking and linting: \nESLint\n\n\nESLint for Visual Studio Code: \nESLint for VSC\n\n\nConfig files in node.js: \nnode-config\n\n\nCommand line parameter parsing in node.js: \nyargs\n\n\nMkDocs for creating doc site: \nMkDocs\n\n\nGitHub Pages (github.io) for hosting docs. Pushing docs to github.io: \nmkdocs gh-deploy --clean\n\n\nPM2\n for auto-starting Butler after server reboot.\n\n\n\n\nDocumentation\n\n\nThe main documentation is built using \nMkDocs\n.\nFrom within the butler-docs folder, run \nmkdocs build --clean\n to generate the static documentation files in the site folder.\nOr run \nmkdocs serve\n, then go to \nhttp://127.0.0.1:8000\n to view a live version of the documentation as you edit (and save) it.", 
            "title": "Tools used"
        }, 
        {
            "location": "/tools-used/#tools_used_to_create_butler", 
            "text": "Below follows a (most likely non complete) list of tools that were used to create Butler. \nIt is intended to serve as a reminder to self for how to carry out various tasks, some of which may only be occasionally used.\nThus, please treat this page for what it is...  On a high level, Butler development is done on OSX, using  Visual Studio Code .  MkDocs  is used to generate the documentation, which together with all files is hosted on GitHub.     Syntax checking and linting:  ESLint  ESLint for Visual Studio Code:  ESLint for VSC  Config files in node.js:  node-config  Command line parameter parsing in node.js:  yargs  MkDocs for creating doc site:  MkDocs  GitHub Pages (github.io) for hosting docs. Pushing docs to github.io:  mkdocs gh-deploy --clean  PM2  for auto-starting Butler after server reboot.", 
            "title": "Tools used to create Butler"
        }, 
        {
            "location": "/tools-used/#documentation", 
            "text": "The main documentation is built using  MkDocs .\nFrom within the butler-docs folder, run  mkdocs build --clean  to generate the static documentation files in the site folder.\nOr run  mkdocs serve , then go to  http://127.0.0.1:8000  to view a live version of the documentation as you edit (and save) it.", 
            "title": "Documentation"
        }
    ]
}